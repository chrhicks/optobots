/**
 * Generated by apidoc - http://www.apidoc.me
 * Service version: 0.0.1-dev
 * apidoc:0.9.27 http://www.apidoc.me/photoop/images/0.0.1-dev/ning_1_8_client
 */
package io.photoop.images.v0.models {

case class Error(
                  code: String,
                  message: String
                  )

case class Image(
                  guid: _root_.java.util.UUID,
                  userGuid: _root_.java.util.UUID,
                  objectId: String
                  )

case class ImageForm(
                      userGuid: _root_.java.util.UUID,
                      data: String
                      )

}

package io.photoop.images.v0.models {

package object json {
  import play.api.libs.json.__
  import play.api.libs.json.JsString
  import play.api.libs.json.Writes
  import play.api.libs.functional.syntax._
  import io.photoop.images.v0.models.json._

  private[v0] implicit val jsonReadsUUID = __.read[String].map(java.util.UUID.fromString)

  private[v0] implicit val jsonWritesUUID = new Writes[java.util.UUID] {
    def writes(x: java.util.UUID) = JsString(x.toString)
  }

  private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
    import org.joda.time.format.ISODateTimeFormat.dateTimeParser
    dateTimeParser.parseDateTime(str)
  }

  private[v0] implicit val jsonWritesJodaDateTime = new Writes[org.joda.time.DateTime] {
    def writes(x: org.joda.time.DateTime) = {
      import org.joda.time.format.ISODateTimeFormat.dateTime
      val str = dateTime.print(x)
      JsString(str)
    }
  }

  implicit def jsonReadsImagesError: play.api.libs.json.Reads[Error] = {
    (
      (__ \ "code").read[String] and
        (__ \ "message").read[String]
      )(Error.apply _)
  }

  implicit def jsonWritesImagesError: play.api.libs.json.Writes[Error] = {
    (
      (__ \ "code").write[String] and
        (__ \ "message").write[String]
      )(unlift(Error.unapply _))
  }

  implicit def jsonReadsImagesImage: play.api.libs.json.Reads[Image] = {
    (
      (__ \ "guid").read[_root_.java.util.UUID] and
        (__ \ "user_guid").read[_root_.java.util.UUID] and
        (__ \ "object_id").read[String]
      )(Image.apply _)
  }

  implicit def jsonWritesImagesImage: play.api.libs.json.Writes[Image] = {
    (
      (__ \ "guid").write[_root_.java.util.UUID] and
        (__ \ "user_guid").write[_root_.java.util.UUID] and
        (__ \ "object_id").write[String]
      )(unlift(Image.unapply _))
  }

  implicit def jsonReadsImagesImageForm: play.api.libs.json.Reads[ImageForm] = {
    (
      (__ \ "user_guid").read[_root_.java.util.UUID] and
        (__ \ "data").read[String]
      )(ImageForm.apply _)
  }

  implicit def jsonWritesImagesImageForm: play.api.libs.json.Writes[ImageForm] = {
    (
      (__ \ "user_guid").write[_root_.java.util.UUID] and
        (__ \ "data").write[String]
      )(unlift(ImageForm.unapply _))
  }
}
}



package io.photoop.images.v0 {
import com.ning.http.client.{AsyncCompletionHandler, AsyncHttpClient, AsyncHttpClientConfig, Realm, Request, RequestBuilder, Response}

object Constants {

  val UserAgent = "apidoc:0.9.27 http://www.apidoc.me/photoop/images/0.0.1-dev/ning_1_8_client"
  val Version = "0.0.1-dev"
  val VersionMajor = 0

}

class Client(
              apiUrl: String,
              auth: scala.Option[io.photoop.images.v0.Authorization] = None,
              defaultHeaders: Seq[(String, String)] = Nil,
              asyncHttpClient: AsyncHttpClient = Client.defaultAsyncHttpClient
              ) {
  import org.slf4j.Logger
  import org.slf4j.LoggerFactory
  import io.photoop.images.v0.models.json._

  val logger = LoggerFactory.getLogger(getClass)

  def images: Images = Images

  object Images extends Images {
    override def get(
                      guid: _root_.scala.Option[_root_.java.util.UUID] = None,
                      userGuid: _root_.scala.Option[_root_.java.util.UUID] = None,
                      limit: Int = 25,
                      offset: Int = 0
                      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.photoop.images.v0.models.Image]] = {
      val queryParameters = Seq(
        guid.map("guid" -> _.toString),
        userGuid.map("user_guid" -> _.toString),
        Some("limit" -> limit.toString),
        Some("offset" -> offset.toString)
      ).flatten

      _executeRequest("GET", s"/images", queryParameters = queryParameters).map {
        case r if r.getStatusCode == 200 => _root_.io.photoop.images.v0.Client.parseJson("Seq[io.photoop.images.v0.models.Image]", r, _.validate[Seq[io.photoop.images.v0.models.Image]])
        case r => throw new io.photoop.images.v0.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200", requestUri = Some(r.getUri))
      }
    }

    override def post(
                       imageForm: io.photoop.images.v0.models.ImageForm
                       )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.photoop.images.v0.models.Image] = {
      val payload = play.api.libs.json.Json.toJson(imageForm)

      _executeRequest("POST", s"/images", body = Some(payload)).map {
        case r if r.getStatusCode == 200 => _root_.io.photoop.images.v0.Client.parseJson("io.photoop.images.v0.models.Image", r, _.validate[io.photoop.images.v0.models.Image])
        case r if r.getStatusCode == 409 => throw new io.photoop.images.v0.errors.ErrorsResponse(r)
        case r => throw new io.photoop.images.v0.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200, 409", requestUri = Some(r.getUri))
      }
    }

    override def deleteByUserGuidAndGuid(
                                          userGuid: _root_.java.util.UUID,
                                          guid: _root_.java.util.UUID
                                          )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.photoop.images.v0.models.Image] = {
      _executeRequest("DELETE", s"/images/${userGuid}/${guid}").map {
        case r if r.getStatusCode == 200 => _root_.io.photoop.images.v0.Client.parseJson("io.photoop.images.v0.models.Image", r, _.validate[io.photoop.images.v0.models.Image])
        case r if r.getStatusCode == 409 => throw new io.photoop.images.v0.errors.ErrorsResponse(r)
        case r => throw new io.photoop.images.v0.errors.FailedRequest(r.getStatusCode, s"Unsupported response code[${r.getStatusCode}]. Expected: 200, 409", requestUri = Some(r.getUri))
      }
    }
  }

  def _logRequest(request: Request) {
    logger.info("_logRequest: " + request)
  }

  def _requestBuilder(method: String, path: String): RequestBuilder = {
    val builder = new RequestBuilder(method)
      .setUrl(apiUrl + path)
      .addHeader("User-Agent", Constants.UserAgent)
      .addHeader("X-Apidoc-Version", Constants.Version)
      .addHeader("X-Apidoc-Version-Major", Constants.VersionMajor.toString)

    defaultHeaders.foreach { h => builder.addHeader(h._1, h._2) }

    auth.fold(builder) { a =>
      a match {
        case Authorization.Basic(username, password) => {
          builder.setRealm(
            new Realm.RealmBuilder()
              .setPrincipal(username)
              .setUsePreemptiveAuth(true)
              .setScheme(Realm.AuthScheme.BASIC)
              .build()
          )
        }
        case _ => sys.error("Invalid authorization scheme[" + a.getClass + "]")
      }
    }
  }

  def _executeRequest(
                       method: String,
                       path: String,
                       queryParameters: Seq[(String, String)] = Seq.empty,
                       body: Option[play.api.libs.json.JsValue] = None
                       )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.ning.http.client.Response] = {
    val request = _requestBuilder(method, path)

    queryParameters.foreach { pair =>
      request.addQueryParameter(pair._1, pair._2)
    }

    val requestWithParamsAndBody = body.fold(request) { b =>
      val serialized = play.api.libs.json.Json.stringify(b)
      request.setBody(serialized).addHeader("Content-type", "application/json; charset=UTF-8")
    }

    val finalRequest = requestWithParamsAndBody.build()
    _logRequest(finalRequest)

    val result = scala.concurrent.Promise[com.ning.http.client.Response]()
    asyncHttpClient.executeRequest(finalRequest,
      new AsyncCompletionHandler[Unit]() {
        override def onCompleted(r: com.ning.http.client.Response) = result.success(r)
        override def onThrowable(t: Throwable) = result.failure(t)
      }
    )
    result.future
  }

}

object Client {

  private lazy val defaultAsyncHttpClient = {
    new AsyncHttpClient(
      new AsyncHttpClientConfig.Builder()
        .setExecutorService(java.util.concurrent.Executors.newCachedThreadPool())
        .build()
    )
  }

  def parseJson[T](
                    className: String,
                    r: _root_.com.ning.http.client.Response,
                    f: (play.api.libs.json.JsValue => play.api.libs.json.JsResult[T])
                    ): T = {
    f(play.api.libs.json.Json.parse(r.getResponseBody("UTF-8"))) match {
      case play.api.libs.json.JsSuccess(x, _) => x
      case play.api.libs.json.JsError(errors) => {
        throw new io.photoop.images.v0.errors.FailedRequest(r.getStatusCode, s"Invalid json for class[" + className + "]: " + errors.mkString(" "), requestUri = Some(r.getUri))
      }
    }
  }

}

sealed trait Authorization
object Authorization {
  case class Basic(username: String, password: Option[String] = None) extends Authorization
}

trait Images {
  /**
   * Find an image.
   */
  def get(
           guid: _root_.scala.Option[_root_.java.util.UUID] = None,
           userGuid: _root_.scala.Option[_root_.java.util.UUID] = None,
           limit: Int = 25,
           offset: Int = 0
           )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.photoop.images.v0.models.Image]]

  /**
   * Add a new image.
   */
  def post(
            imageForm: io.photoop.images.v0.models.ImageForm
            )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.photoop.images.v0.models.Image]

  /**
   * Soft delete an image for a user
   */
  def deleteByUserGuidAndGuid(
                               userGuid: _root_.java.util.UUID,
                               guid: _root_.java.util.UUID
                               )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.photoop.images.v0.models.Image]
}

package errors {

import io.photoop.images.v0.models.json._

case class ErrorsResponse(
                           response: _root_.com.ning.http.client.Response,
                           message: Option[String] = None
                           ) extends Exception(message.getOrElse(response.getStatusCode + ": " + response.getResponseBody("UTF-8"))){
  lazy val errors = _root_.io.photoop.images.v0.Client.parseJson("Seq[io.photoop.images.v0.models.Error]", response, _.validate[Seq[io.photoop.images.v0.models.Error]])
}

case class FailedRequest(responseCode: Int, message: String, requestUri: Option[_root_.java.net.URI] = None) extends Exception(s"HTTP $responseCode: $message")

}

object PathSegment {
  // See https://github.com/playframework/playframework/blob/2.3.x/framework/src/play/src/main/scala/play/utils/UriEncoding.scala
  def encode(s: String, inputCharset: String): String = {
    val in = s.getBytes(inputCharset)
    val out = new java.io.ByteArrayOutputStream()
    for (b <- in) {
      val allowed = segmentChars.get(b & 0xFF)
      if (allowed) {
        out.write(b)
      } else {
        out.write('%')
        out.write(upperHex((b >> 4) & 0xF))
        out.write(upperHex(b & 0xF))
      }
    }
    out.toString("US-ASCII")
  }

  private def upperHex(x: Int): Int = {
    // Assume 0 <= x < 16
    if (x < 10) (x + '0') else (x - 10 + 'A')
  }

  private[this] val segmentChars: java.util.BitSet = membershipTable(pchar)

  private def pchar: Seq[Char] = {
    val alphaDigit = for ((min, max) <- Seq(('a', 'z'), ('A', 'Z'), ('0', '9')); c <- min to max) yield c
    val unreserved = alphaDigit ++ Seq('-', '.', '_', '~')
    val subDelims = Seq('!', '$', '&', '\'', '(', ')', '*', '+', ',', ';', '=')
    unreserved ++ subDelims ++ Seq(':', '@')
  }

  private def membershipTable(chars: Seq[Char]): java.util.BitSet = {
    val bits = new java.util.BitSet(256)
    for (c <- chars) { bits.set(c.toInt) }
    bits
  }
}
}
